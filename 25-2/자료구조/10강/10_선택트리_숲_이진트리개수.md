# 제10장 선택 트리, 숲, 이진 트리 개수

## 1. 선택 트리

### 합병 정렬과 선택 트리
차례로 정렬한 데이터 리스트 k개를 완전한 순서를 유지하는 하나의 리스트로 만드는 과정을 **합병 정렬**이라고 함

### 선택 트리의 필요성
- 일반적으로 데이터 목록이 k개인 경우, k-1번 비교를 통해 데이터 목록에서 가장 작은 값이나 가장 큰 값을 결정할 수 있음
- 선택 트리를 이용하여 비교 횟수를 줄일 수 있음

### 선택 트리의 개념
- **합병 정렬**: 차례로 정렬한 데이터 리스트 k개를 완전한 순서를 유지하는 하나의 리스트로 만드는 과정
- **선택 트리**: 합병 정렬에 사용하는 특수한 트리
- **승자 트리**: 각 노드가 두 자식 노드의 작은 값(승자)을 갖는 완전 이진 트리
- **패자 트리**: 각 노드가 두 자식 노드의 큰 값(패자)이며 최종 승자는 0번 노드에 저장하는 트리
- **숲**: 분리된 트리 모임, n(≥0)개 이상의 분리된 트리 집합
- **노드 n개인 서로 다른 이진 트리의 개수**: $\frac{(2n)!}{n!(n+1)!}$

### 선택 트리 구성 예시

8개의 정렬된 리스트를 이용한 선택 트리 구성:

```
head  [14]  [20]  [22]  [11]  [12]  [13]  [40]  [17]
      [16]  [26]  [25]  [24]  [18]  [16]  [49]  [19]
      [57]              [28]        [21]
      [68]
       1     2     3     4     5     6     7     8
```

### 승자 트리 특징
1. 각 노드가 두 자식 노드의 작은 값을 갖는 완전 이진 트리
2. 작은 값이 승자가 되어 올라가는 토너먼트 경기와 유사
3. 트리의 각 노드는 두 자식 노드 값의 승자를 자신의 값으로 함
4. 결과적으로 루트의 값이 트리에서 가장 작은 값이 됨

### 승자 트리 동작 원리
- 첫번째 단계에서의 비교 횟수를 줄이는 목적이지만, 두번째 비교단계부터는 비교 횟수가 감소됨
- 재구성 과정에서 빈 리스트가 생기면 큰 값(∞)을 넣어줌

### 승자 트리 구성 과정

**초기 상태**: 8개의 정렬된 리스트 예시
```
head  [14]  [20]  [22]  [11]  [12]  [13]  [40]  [17]
      [16]  [26]  [25]  [24]  [18]  [16]  [49]  [19]
      [57]              [28]        [21]
      [68]
       1     2     3     4     5     6     7     8
```

**승자 트리 구성 전 단계**: 각 리스트의 head 값들을 토너먼트 방식으로 비교하여 승자를 결정

**최초 승자 트리 구성**: 모든 leaf 노드에서 시작하여 부모 노드로 올라가며 승자를 결정, 최종적으로 루트에는 11이 위치

**승자 트리 재구성**: 11을 제거한 후 4번 리스트의 head에 위치한 24를 패자 트리에 올려보내고 경쟁을 시킴

<details>
<summary>승자 트리 구성 과정</summary>

1. 각 리스트의 head 위치한 데이터 중에서 가장 작은 값을 선택
2. 토너먼트 방식으로 승자를 결정하여 부모 노드로 올림
3. 루트에 도달한 값이 전체 최솟값
4. 선택된 값을 제거하고 해당 리스트의 다음 데이터로 재구성

</details>

### 패자 트리

패자 트리는 승자 트리와 유사하지만 다음과 같은 차이점이 있음

**패자 트리 특징**
- 각 노드가 두 자식 노드 중에서 더 작은 값을 갖는 완전 이진 트리라는 점은 승자 트리와 같지만, 패자 트리는 루트 노드 위에 **최상위 0번 노드**를 가짐

**패자 트리 구성 요소**
- 최상위 0번 노드에는 최종 승자를 저장함
- 잎 노드들이 각 리스트의 head를 가리킴  
- 트리의 각 내부 노드에는 승자가 아닌 패자를 저장함 (즉, 패자를 부모 노드에 저장하고 승자는 부모의 부모 노드로 올라가서 다시 경쟁)
- 루트에는 마지막 패자를 저장하고 최종 승자는 0번 노드에 저장

**패자 트리 재구성 과정**
1. 0번 노드에 최소값이 있으므로 이 값을 제거하여 전체 리스트에 저장함
2. 제거된 값을 가지고 있던 4번 리스트의 head에 위치한 값 24를 패자 트리에 올려 보내고 경쟁을 시킴
3. 패자 트리를 재구성함

**패자 트리의 장점**
- 같은 과정을 반복하면 전체 리스트를 하나로 정렬할 수 있음
- 재구성 과정에서 필요한 계산 시간은 O(n log k)임 - 또한 승자 트리는 완전 이진 트리이기 때문에 배열로 쉽게 구현할 수 있음
- 선택 트리를 사용하는 경우 트리의 레벨은 log k+1이므로 선택 트리를 재구성하는 시간은 O(log k)이고, 따라서 n개의 데이터를 모두 합병하는 데 필요한 계산 시간은 O(n log k)

## 2. 숲

### 숲의 정의
분리된 트리 모임을 **숲(forest)**이라 부름. n(≥0)개 이상의 분리된 트리 집합

### 숲의 종류
- **빈 숲**: 트리가 하나도 없는 상태
- **불완전 숲**: 일부 노드만 있는 상태  
- **완전 숲**: 모든 노드가 연결된 상태
- **일반 숲**: 여러 개의 독립적인 트리들

### 숲을 이진 트리로 변환

숲을 이진 트리로 변환하는 원리:
```
트리 T₁, T₂, ⋯, Tₙ으로 구성된 숲에 대한 이진 트리 BT₁~ₙ

① n = 0이면 BT₁~ₙ = 빈 이진 트리
② n = 1이면 BT₁ = T₁ᴮᵀ  
③ n ≥ 2이면
        rootT₁ᴮᵀ
        /        \
   T₁ᴮᵀ 왼쪽 서브트리   BT₂~ₙ
```

여기서 T₁ᴮᵀ는 트리 T₁을 (루트가 왼쪽 서브트리만 갖도록) 이진 트리로 변환한 것

### 변환 과정
1. 첫 번째 트리를 이진 트리로 변환하여 루트의 왼쪽 서브트리로 배치
2. 나머지 숲을 순환적으로 오른쪽 서브트리로 변환
3. 이 과정을 반복하여 전체 숲을 하나의 이진 트리로 변환

### 이진트리로 변환 방법

**단일 트리 변환**
각 트리를 루트의 왼쪽만 자식으로 가지는 이진트리로 변환

**숲 전체 변환**  
각 트리를 루트의 왼쪽만 자식으로 가지는 이진트리로 변환하여 오른쪽 자식으로 이진트리를 지정

## 3. 이진 트리 개수

### 노드와 이진트리의 관계
**노드 개수에 따른 가능한 이진 트리**

- **n = 0**: ∅ (빈 트리) - 1개
- **n = 1**: 단일 노드 - 1개  
- **n = 2**: 2가지 구조 가능

### 노드 개수가 3개인 이진 트리의 개수
**노드 개수 3인 이진 트리 구조**

노드가 3개인 이진 트리에서 전위 순회 방문 순서가 1, 2, 3인 이진 트리는 총 5가지 구조가 가능

### 전위 순회와 중위 순회를 통한 트리 결정

**핵심 원리**
- 전위 순회로 첫 번째 방문한 노드가 1이라면, 1은 루트
- 중위 순회 방문순서는 1이 가장 먼저 나오므로 3, 2는 노드 1의 오른쪽 서브 트리

**예시 분석**
전위 순회 또 번째 방문한 노드가 2이고 중위 순회의 경우 3번 노드가 먼저 방문되므로 → 노드 3이 노드 2의 왼쪽 서브 트리임

### 어떤 이진 트리에 대한 전위 순회와 중위 순회 방문 순서가 주어지면 트리 구조를 유일하게(한 개) 정할 수 있음

### 스택을 이용한 이진 트리의 순회

**스택 활용 개념**
- 1부터 n까지 수를 스택에 넣었다가 가능한 모든 방법으로 삭제하여 생성할 수 있는 경우의 수와 n개의 노드를 가진 상이한 이진 트리의 수가 같음
- 전위 순회 방문 순서를 스택에 넣고 push/pop 연산을 이용하여 중위 순회 방문 순서를 만들어내면서, 유일한 이진 트리를 결정할 수 있음

**push() 연산의 의미**
- 트리 생성 과정으로 껍데기 노드와 왼쪽 서브 트리를 나타냄
- 삽입된 노드보다 먼저 pop()을 원소가 존재함
- 삽입된 노드의 왼쪽 서브 트리가 될 노드가 존재함

**pop() 연산의 의미**  
- 껍데기 노드에 값을 넣고 오른쪽 서브 트리로 이동하는 것
- 왼쪽 서브 트리와 오른쪽 서브 트리의 중간에 도달했다는 의미
- 중위순회에서 노드에 값을 넣은 후에, 오른쪽 서브 트리로 이동함

### 카탈란 수와 이진 트리

**수학자 카탈란(Eugene Charles Catalan)이 증명**
노드 n개인 서로 다른 이진 트리의 개수가 다음과 같음을 증명:

$\frac{(2n)!}{n!(n+1)!}$

**카탈란 수열**
n = 0부터 몇 개 대입해 보면 '1, 1, 2, 5, 14, 42, 132, 429, 1430, ⋯'

**스택 연산 표**

전위 순회 방문 순서가 1, 2, 3이고 중위 순회 방문 순서가 1, 3, 2인 경우:

| 연산 | 스택 | 출력 | 트리 |
|------|------|------|------|
| push(1) | 1 | - | 1 (오른쪽) |
| pop() | - | 1 | 1을 출력 |
| push(2) | 2 | 1 | 2를 1의 왼쪽 자식으로 |
| push(3) | 2, 3 | 1 | 3을 2의 왼쪽 자식으로 |
| pop() | 2 | 1, 3 | 3을 출력 |
| pop() | - | 1, 3, 2 | 2를 출력 |

## 핵심 개념 정리

### 선택 트리의 응용
1. 대용량 데이터의 효율적인 정렬
2. 우선순위 큐 구현
3. 외부 정렬 알고리즘

### 시간 복잡도 분석
- **승자 트리 구성**: O(k log k) - k는 리스트 개수
- **최솟값 선택**: O(log k)
- **트리 재구성**: O(log k)
- **전체 정렬**: O(n log k) - n은 전체 데이터 수

### 공간 복잡도
- 승자 트리: O(k) 추가 공간 필요
- 패자 트리: O(k) 추가 공간 필요

## 실전 활용

### 합병 정렬에서의 활용
여러 정렬된 리스트를 효율적으로 합병할 때 선택 트리 사용으로 비교 횟수를 현저히 줄일 수 있음

### 외부 정렬
메모리에 모든 데이터를 올릴 수 없는 경우, 선택 트리를 이용하여 효율적인 외부 정렬 구현 가능

## 주요 공식과 정리

### 카탈란 수 공식
n개의 노드를 가진 서로 다른 이진 트리의 개수:
$C_n = \frac{(2n)!}{n!(n+1)!}$

### 트리 변환 관련
- 숲 → 이진트리 변환: n(≥0)개 이상의 분리된 트리 집합
- 노드 n개인 서로 다른 이진 트리의 개수: $\frac{(2n)!}{n!(n+1)!}$