# 5. 연결 리스트

## 학습 목표
1. 리스트와 배열의 차이점을 이해함
2. 연결 리스트의 구현을 위한 포인터 개념을 이해함  
3. 연결 리스트의 노드 삽입을 위한 포인터 변수의 운영을 이해함

## 용어 정리

- **리스트(list)**: 원소들 간의 순서를 지켜서 나열하는 자료구조
- **원소들 간의 순서**: 데이터가 물리적인 위치와 상관없이 사람들의 머릿속에 인식되는 '논리적인 순서', 혹은 원소들 간의 '의미적인 순서'
- **노드(node)**: 데이터와 다음 원소를 가리키는 주소값으로 구성된 자료단위  
- **포인터(pointer)**: 메모리에 저장된 데이터의 저장 위치에 대한 주소를 가리키는 데이터형
- **단항 연산자**: 피연산자를 하나만 갖는 연산자
- **구조체(struct)**: 다양한 데이터형의 변수들을 하나의 상자 안에 넣어서 선언하거나 사용하는 C 프로그래밍 문법

## 1. 리스트의 개념

### 1.1 리스트와 배열의 차이점

**리스트의 '순서'** 개념은 배열에서의 '순서'와 다름:
- **배열의 순서**: 메모리 공간에서의 물리적 저장 위치 (DDR에서의 순서)
- **리스트의 순서**: 데이터가 저장되는 물리적인 위치와 상관없이 사람들의 머릿속에 인식되는 '논리적인 순서', 혹은 리스트에 나타나는 원소들 간의 '의미적인 순서'

**예시**: 한국 역사적 사건의 시간적 순서
- 3·1 운동(1919) → 8·15 광복(1945) → 6·25 전쟁(1950) → 서울 올림픽(1988)

**'논리적인 순서' 혹은 '의미적인 순서'란?**: 가장 간단한 예가 바로 시간순으로 되어 있는 연대표임

### 1.2 리스트 개념의 중요성

리스트는 '물품이나 사람의 이름 따위를 적어 놓은 것'이 아니라 '순서'가 있는 것이 핵심임. 순서와 관련된 자료구조를 이미 학습했는데 바로 배열(Array)임.

### 1.3 연결 리스트의 필요성

배열로 리스트를 구현할 때의 문제점:
1. 원소의 삽입/삭제 시 다른 모든 원소의 이동 필요
2. 프로그램 실행 시간의 비효율성 증가
3. 실제 IT 서비스 환경에서 빈번한 삽입/삭제 발생

따라서 논리적인 순서를 메모리 공간에서의 물리적 순서를 의미하지 않게 하면서 순서를 표현할 방법이 필요함.

## 2. 배열을 이용한 리스트의 구현

### 2.1 배열 구현의 특징
- 연속적인 메모리 공간에 순차적으로 저장
- 삽입 시: 뒤의 모든 원소들을 한 칸씩 뒤로 이동
- 삭제 시: 뒤의 모든 원소들을 한 칸씩 앞으로 이동

### 2.2 삽입 연산의 비효율성

만약 리스트의 원소 개수가 2,000개이며, 프로그램의 수행 중에 리스트 원소값이 하나 추가되는 상황을 가정해 봄:
- 추가되는 원소가 앞에서 두 번째 위치에 삽입되어야 한다면
- 모두 1,999개의 리스트의 원소가 뒤로 밀려나야 함

이러한 원소 수가 많을수록 프로그램의 수행 시간을 증가시킴. 특히 리스트 원소의 삽입은 프로그램의 실행 중에 메모리 할당을 필요로 하는 경우도 발생시킴.

### 2.3 삭제 연산의 비효율성

삭제할 때도 마찬가지로 삭제 원소 이후의 모든 원소들을 앞으로 당겨와야 하는 상황이 발생함.

## 3. 포인터를 이용한 리스트의 구현

### 3.1 연결 리스트의 아이디어

이러한 문제점을 해결하기 위해 포인터를 이용한 구현 방법을 알아보고자 함. 포인터를 이용하는 방법은 원소의 자리에는 다음 원소를 가리키는 다음 원소가 있는 곳의 주소를 같이 기록해두는 것임.

### 3.2 연결 리스트와 노드의 개념

프로그램에서 원소값을 저장하는 공간을 node라고 부름. 노드는 데이터 요소와 다음 원소를 지시하는 포인터(pointer, 주소)가 있다고 생각하면 됨. 이 포인터는 링크(link)라고도 부름.

**식사 쪽지 비유**:
- 첫 번째 상자에는 아침 식사가 들어 있고
- 두 번째 상자에는 점심 식사가 있는 셋째 칸에 이어 아침 
- 셋째 상자에는 점심 식사와 점심 식사가 있는 TV 앞에 있다는 쪽지가 적힌 곳
- 개의 상자들이 쪽지를 통해 연결되어 있음

### 3.3 포인터 기본 개념

포인터는 메모리 주소값을 저장하는 변수:

```c
int a = 100;    // 정수형 변수 a에 100 저장
int *b;         // 정수형 포인터 변수 b 선언
b = &a;         // a의 주소를 b에 저장
```

### 3.4 포인터 연산자

1. **주소 연산자(&)**: '역참조 연산자'라고 하며 변수의 메모리 주소를 반환
   - 단항 연산자라고 하며, 이항 연산자와는 달리 단항 연산자는 하나의 피연산자를 필요로 함
   - &는 '주소 연산자'라고도 함

2. **역참조 연산자(*)**: 포인터가 가리키는 메모리 위치의 값을 반환

### 3.5 포인터와 자료형의 일치

포인터 변수가 특정 자료형의 주소값을 저장하도록 선언하는 방법은 다른 변수의 선언과 아주 유사함:
- 정수형 변수에 대한 포인터 변수는 정수형 포인터 변수여야 함
- 실수형 변수에 대한 포인터 변수는 실수형 포인터 변수여야 함

### 3.6 포인터 선언과 활용

포인터 변수에 주소값을 할당하기 위해서 새로운 연산자 &가 새롭게 나타남:
- &는 단항 연산자라고 하며, 이항 연산자가 두 개의 피연산자가 필요한 연산자임
- 대표적인 이항 연산자가 사칙연산자 +, -, *, / 등임
- 단항 연산자는 하나의 피연산자를 필요로 함
- &는 '역참조 연산자'라고도 함

### 3.7 구조체(Struct) 정의

연결 리스트에서 노드를 생성해 보면, 리스트 원소값을 저장하는 부분(데이터 부분)과 다음 원소를 가리키는 부분(링크 부분)이 있다는 것을 알 수 있음.

즉, 값을 저장하는 부분과 링크를 저장하는 부분이 하나의 상자 안에 들어가 있는 것을 알 수 있음. 이러한 다양한 데이터형의 변수를 하나의 단위로 다룰 수 있게 하기 위해서 다양한 정보를 보관할 수 있게 해주는 자료구조가 필요함.

```c
typedef struct ListNode {    // 단순 연결 리스트의 노드 구조 정의
    int data;
    struct ListNode* link;
} listNode;

typedef struct {             // 리스트의 헤드(first) 노드 구조 정의  
    listNode* head;
} linkedList_h;
```

**구조체 정의 설명**:
1. 'typedef struct' 선언문을 사용하여 정의함
2. 데이터 필드 부분은 정수형 변수(int 변수)를 사용하여 data의 공간을 할당함. data는 숫자 데이터를 의미함
3. 링크 필드 부분은 다음 노드의 주소값을 저장하여 가리키고 있어야 하기 때문에 노드 구조의 자료형 ListNode 포인터를 사용하여 정의함
4. 노드 구조의 자료형 ListNode 포인터는 ListNode 노드 전체를 가리키는 포인터 변수임

## 4. 프로그램 실행 중의 구조체 메모리 할당

### 4.1 동적 메모리 할당의 필요성

배열을 이용한 리스트의 구현과 포인터를 이용한 리스트의 구현은 확장성에서도 차이가 있을 수 있음. 배열은 프로그램의 실행 전에 배열 크기를 결정하여 선언함. 그래서 배열이 실제 리스트 원소의 숫자보다 작게 되면 메모리를 낭비하고, 실행 중에 리스트 원소의 숫자가 배열보다 크게 되면 문제를 발생시킴.

### 4.2 malloc()과 free() 함수

```c
// 메모리 할당 - 정수형 크기만큼 공간 할당
int *p_a = (int *)malloc(sizeof(int));
*p_a = 10;

// 메모리 할당 - 실수형 크기만큼 공간 할당  
float *p_b = (float *)malloc(sizeof(float));
*p_b = 3.14;

// 메모리 해제
free(p_a);
free(p_b);
```

**주요 사항**:
- sizeof(int): 정수형(int) 데이터의 메모리 공간 크기를 반환
- sizeof(float): 실수형(float) 데이터의 메모리 공간 크기를 반환
- malloc()으로 할당받은 메모리는 반드시 free()로 해제해야 함
- 마지막의 free() 함수는 malloc() 함수를 이용하여 할당받은 메모리 공간을 없애 버리고, 다시 사용할 수 있도록 해 주면 됨

## 5. 연결 리스트에서 노드의 삽입과 삭제

### 5.1 삭제 연산의 원리

**삭제 연산의 단계적 수행**:
1. 삭제할 노드의 선행 노드의 링크 필드를 삭제할 노드의 후행 노드를 가리키게 함
2. 삭제할 노드를 메모리에서 반환함

**예시**: 노드 x를 삭제하는 경우
- x 노드의 선행 노드 i가 가리키는 노드
- x 노드의 후행 노드 j를 가리키는 노드  
- i 노드의 link가 j 노드를 가리키게 하면 x 노드는 링크에서 제외됨

### 5.2 삽입 연산의 원리

**새로운 노드를 i와 j 사이에 삽입하는 단계**:
1. 메모리 공간을 할당받고 삽입할 Y 노드를 생성
2. Y 노드의 링크 필드가 X 노드의 후행 노드를 가리키게 함  
3. Y 노드의 선행 노드가 된 X 노드의 링크 필드가 Y 노드를 가리키게 함

**삽입 연산의 주의사항**: 
- 순서가 중요함 - 잘못된 순서로 하면 노드들 사이의 연결이 끊어질 수 있음

## 6. 연결 리스트의 여러 가지 연산 프로그램

### 6.1 연결 리스트의 생성

```c
linkedList_h* createLinkedList_h(void) {    // 연결리스트 생성
    linkedList_h* H;
    H = (linkedList_h*)malloc(sizeof(linkedList_h));
    H->head = NULL;
    return H;
}
```

**헤드 노드의 역할**:
- 일반적으로 '헤드 노드'라고 불리며, 연결 리스트의 처음을 가리키는 역할을 함
- 헤드 노드는 데이터 필드 부분이 필요 없으므로, 여기서는 자료형 ListNode를 가리킬 수 있도록 'listNode* head'라고 정의함

### 6.2 연결 리스트의 노드 삽입

```c
void addNode(linkedList_h* H, int x) {
    // 리스트 마지막 노드에 삽입 연산하며, x값은 100이라고 가정함
    listNode* NewNode;
    listNode* LastNode;
    
    NewNode = (listNode*)malloc(sizeof(listNode));
    NewNode->data = x;
    NewNode->link = NULL;
    
    if(H->head == NULL) {        // 현재 공백인 경우
        H->head = NewNode;
        return;
    }
    
    LastNode = H->head;
    while(LastNode->link != NULL) 
        LastNode = LastNode->link;
    LastNode->link = NewNode;
}
```

**첫 번째 노드 삽입**:
- 현재 연결 리스트에 연결된 노드가 없기 때문에 if 비교문이 참이 되어 실행됨
- 헤드 노드(H)가 새로 생성한 노드(NewNode)를 가리키게 함

**두 번째 노드 삽입**:
- 이번에는 앞에서 만든 연결 리스트 마지막 노드 뒤에 노드(NewNode)를 1개 생성하여 데이터 값에는 x값(200)을 넣고자 함

### 6.3 연결 리스트의 특정 노드 뒤에 삽입

```c
void additNode(linkedList_h* H, listNode* prevNode, int itdata) {
    // 리스트 중간에 노드를 삽입하는 연산하며, itdata 값은 150이라고 가정함
    listNode* NewNode;
    NewNode = (listNode*)malloc(sizeof(listNode));
    NewNode->data = itdata;
    NewNode->link = NULL;
    
    NewNode->link = prevNode->link;
    prevNode->link = NewNode;
    return;
}
```

**삽입 순서의 중요성**:
- NewNode의 링크 필드에 prevNode가 가리키고 있는 것(주소값 5500)을 NewNode가 가리키게 하고
- prevNode가 NewNode를 가리키도록 해야 함
- 만약 순서를 지키지 않고 prevNode를 먼저 NewNode가 가리키게 한다면, prevNode의 후행 노드의 주소값이 사라지게 되어 오류가 발생함

### 6.4 연결 리스트의 노드 삭제

```c
void deleteNode(linkedList_h* H) {          // 리스트의 마지막 노드 삭제 연산
    listNode* prevNode;
    listNode* delNode;
    
    if(H->head == NULL) return;             // 공백 리스트인 경우, 삭제 연산 중단
    
    if(H->head->link == NULL) {             // 리스트에 노드가 한 개인 경우
        free(H->head);                      // 첫 번째 노드의 메모리를 해제
        H->head = NULL;
        return;
    }
    else {                                  // 리스트에 노드가 여러 개 있는 경우
        prevNode = H->head;
        delNode = H->head->link;
        
        while(delNode->link != NULL) {
            prevNode = delNode;
            delNode = delNode->link;
        }
        free(delNode);
        prevNode->link = NULL;
    }
}
```

**삭제 연산의 고려사항**:
1. 공백 리스트인지 확인
2. 노드가 한 개만 있는지 확인
3. 여러 개의 노드가 있는지 확인

### 6.5 연결 리스트의 특정 노드의 검색 및 삭제

```c
void findandDeleteNode(linkedList_h* H, int itdata) {
    // 연결 리스트에서 특정 노드를 검색하여 삭제하고자 하는 연산, itdata=200
    listNode* prevNode;
    listNode* delNode;
    
    if(H->head == NULL) return;             // 공백 리스트
    
    prevNode = H;
    delNode = H->head;
    
    while(delNode != NULL) {
        if(delNode->data == itdata) {
            deleteitNode(H, prevNode, delNode);
            return;
        }
        else {
            prevNode = delNode;
            delNode = delNode->link;
        }
    }
}

void deleteitNode(linkedList_h* H, listNode* prevNode, listNode* delNode) {
    // 연결 리스트에서 데이터의 값이 200인 노드(delNode)를 삭제하는 연산
    prevNode->link = delNode->link;
    free(delNode);
    return;
}
```

**검색 및 삭제 과정**:
1. 우선 연결 리스트가 공백인지 여부를 확인함
2. 검색하고자 하는 노드의 앞 노드를 가리킬 수 있는 변수로 prevNode를 정의함  
3. 삭제되는 노드의 앞 노드를 가리킬 수 있도록 prevNode의 위치를 우선 헤드 노드(H)로 정함
4. delNode가 연결 리스트의 첫 번째 노드를 가리키도록 함

## 핵심 개념 정리

### 리스트의 본질적 개념
1. **리스트의 '순서'**: 데이터가 저장되는 물리적인 위치와 상관없이 사람들의 머릿속에 인식되는 '논리적인 순서'
2. **'논리적인 순서' vs '의미적인 순서'**: 가장 간단한 예가 바로 시간순으로 되어 있는 연대표

### 배열과 연결리스트 비교
3. **배열의 한계**: 
   - 삽입/삭제 시 비효율적 (원소 이동 필요)
   - 대량 데이터 처리 시 실행 시간 증가
   - 메모리 공간의 낭비 가능성

4. **연결리스트의 장점**: 
   - 포인터 조작으로 효율적 삽입/삭제 가능
   - 동적 메모리 할당으로 확장성 확보
   - 물리적 위치와 논리적 순서 분리

### 포인터와 메모리 관리
5. **포인터의 역할**: 
   - 원소의 자리(메모리)에는 원소값을 저장
   - 다음 원소를 가리키는 정보의 자리에는 다음 원소가 저장된 위치의 주소값(포인터)을 저장

6. **노드 구성**: 데이터 요소(원소)와 리스트의 다음 원소를 지시하는 포인터(주소)로 구성

7. **메모리 관리**: malloc()으로 할당받은 메모리는 반드시 free()로 해제해야 함

### 연산의 핵심 원리
8. **삽입/삭제 연산**: 포인터(링크) 조작만으로 효율적 수행 가능

9. **연산 순서의 중요성**: 특히 삽입 연산에서 잘못된 순서는 연결 끊김을 야기할 수 있음
