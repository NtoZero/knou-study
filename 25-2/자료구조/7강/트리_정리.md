# 7장 트리

## 개관

트리는 노드 혹은 정점으로 구성되며, 사이의 포함 관계를 나타낼 수 있는 비선형 자료구조다. 이를 트리라고 하는 이유는 용어도 나무와 관련된 단어를 사용하기 때문이다. 트리에서는 어느 노드에서든 다른 노드로 가는 경로가 유일하다는 특성이 있다.

특히 속한 개념은 이진 트리다. 이진 트리는 정리하기도 쉽고 컴퓨터 내부에 구현하기도 쉬워 널리 사용된다.

## 1. 트리의 용어와 표현 방법

### 트리 분류
트리는 크게 Binary Tree(이진 트리)와 m-way Tree(다원 트리)로 구분된다.

- **Binary Tree**: Heap, Binary Search Tree
  - AVL Tree, BB Tree, Splay Tree
- **m-way Tree**: Trie, m-ary Search Tree
  - B-tree, B*-Tree, B+-Tree, 2-3 Tree, 2-3-4 Tree, Red-Black Tree

### 주요 용어 정리

1. **트리(tree)**: 노드들과 선으로 구성된 계층적 구조
2. **루트(root)**: 트리에서 부모를 갖지 않은 노드
3. **진입 차수**: 트리에 대해 각 노드에서 들어오는 선의 개수
4. **진출 차수**: 트리에 대해 각 노드에서 나가는 선의 개수
5. **내부 노드**: 잎이 아닌 노드
6. **형제(sibling)**: 같은 부모를 갖는 노드들
7. **전 이진 트리**: 모든 노드가 0 또는 2개의 자식을 갖는 트리
8. **가득 찬 이진 트리**: 이진 트리에서 최대 개수의 노드를 가진 트리
9. **완전 이진 트리**: 높이가 k인 이진 트리가 레벨 0부터 k-2까지 모두 채우고 k-1 레벨에서 왼쪽부터 오른쪽으로 차례로 채워진 트리
10. **순회(traverse)**: 트리의 각 노드를 빠짐없이 한 번만 방문하는 것

### 트리 성질
- 루트 노드의 진입 차수는 0
- 루트를 제외한 모든 노드의 진입 차수는 1
- 트리에 속하는 노드가 n개이면 선의 개수는 n-1개

## 2. 용어와 논리적 표현 방법

### 노드 관계
- **부모(parent)**: 특정 노드의 상위 노드
- **자식(children)**: 특정 노드의 하위 노드들
- **조상(ancestor)**: 루트에서 특정 노드까지의 경로상의 모든 노드
- **후손(descendant)**: 특정 노드 아래의 모든 노드

### 노드 차수와 레벨
- **노드의 차수(degree of a node)**: 진출 차수로 정의
- **트리의 차수(degree of a tree)**: 트리 내에 있는 각 노드의 차수 가운데 최대 차수
- **레벨(level)**: 루트로부터 그 노드까지 이어진 길이

### 표현 방법
1. **중첩된 집합으로 표현**
2. **중첩된 괄호로 표현**
3. **들여쓰기 표현**

## 3. 추상 자료형

트리의 주요 연산:
- **Tree Create()**: 빈 트리 생성
- **Destroy(Tree)**: 트리 소멸
- **Tree Copy_Tree(Tree)**: 트리의 복사본 생성
- **Insert(n)**: 노드 n 삽입
- **Delete()**: 노드 삭제
- **Search()**: 특정 키값을 갖는 노드 검색
- **Traverse()**: 트리를 순회하고 순서대로 값을 출력
- **Root()**: 루트 노드 반환
- **Parent(n)**: 노드 n의 부모 노드 반환
- **Children(n)**: 노드 n의 자식 노드들 반환

## 4. 이진 트리

### 4.1 이진 트리 개요

이진 트리에 속한 모든 노드의 차수가 2 이하인 트리를 이진 트리라고 한다. 이진 트리는 수학적으로 이론을 정리하기 쉽고, 컴퓨터 내부에 구현하기도 쉬워 자주 사용한다.

### 이진 트리의 종류

1. **전 이진 트리(full binary tree)**: 모든 노드가 0 또는 2개의 자식을 가짐
2. **가득 찬 이진 트리(perfect binary tree)**: 각 레벨이 허용되는 최대 개수 노드를 가짐
3. **완전 이진 트리(complete binary tree)**: 높이가 k인 이진 트리가 레벨 0부터 k-2까지 모두 채우고 k-1 레벨에서 왼쪽부터 오른쪽으로 차례로 채워진 트리

### 수식 관계
높이가 k인 가득 찬 이진 트리의 노드 개수:
```
2^0 + 2^1 + ... + 2^(k-1) = Σ(i=0 to k-1) 2^i = 2^k - 1
```

### 4.2 이진 트리 구현

이진 트리는 연속된 배열에 저장할 수 있다. 이 방법은 이진 트리가 가득 찬 이진 트리라고 가정하고 각 레벨에 있는 노드를 대응하는 위치에 차례로 저장한다.

그러나 보통 연결 리스트를 사용한다. 이진 트리를 구현하기 위한 연결 리스트의 노드는 데이터, 왼쪽 서브트리 포인터, 오른쪽 서브트리 포인터를 필드로 구성한다.

```c
typedef struct node {
    struct node *left;
    char data;
    struct node *right;
} node;
```

## 5. 이진 트리 연산

### 5.1 이진 트리 순회

트리의 각 노드를 빠짐없이 한 번만 방문하는 것을 순회(traverse)라고 한다. 트리 순회에서 방문이란 출력한다로 생각하면 좋다.

#### 순회 방법
루트를 방문(P), 왼쪽 서브트리 순회(L), 오른쪽 서브트리 순회(R)의 순서에 따라:

1. **전위 순회(PLR - preorder)**
   - ① 루트를 방문
   - ② 왼쪽 서브트리를 전위 순회로 순회
   - ③ 오른쪽 서브트리를 전위 순회로 순회

2. **중위 순회(LPR - inorder)**
   - ① 왼쪽 서브트리를 중위 순회로 순회
   - ② 루트를 방문
   - ③ 오른쪽 서브트리를 중위 순회로 순회

3. **후위 순회(LRP - postorder)**
   - ① 왼쪽 서브트리를 후위 순회로 순회
   - ② 오른쪽 서브트리를 후위 순회로 순회
   - ③ 루트를 방문

#### 순회 알고리즘 구현

```c
void preorder(node* root) {
    if(root != NULL) {
        printf("%c ", root->data);
        preorder(root->left);
        preorder(root->right);
    }
}

void inorder(node* root) {
    if(root != NULL) {
        inorder(root->left);
        printf("%c ", root->data);
        inorder(root->right);
    }
}

void postorder(node* root) {
    if(root != NULL) {
        postorder(root->left);
        postorder(root->right);
        printf("%c ", root->data);
    }
}
```

### 5.2 이진 트리 생성, 삽입, 삭제

#### 노드 삽입
새로운 노드를 기존 노드의 자식으로 삽입하는 과정:
1. 새로운 노드를 생성
2. 해당 위치에 연결

```c
node *insert(node *here, node *it) {
    if(here == NULL) {
        here = it;
        return NULL;
    } else {
        node* victim;
        victim = here;
        *here = *it;
        return victim;
    }
}
```

#### 노드 삭제
- **잎 노드 삭제**: 해당 노드를 NULL로 지정
- **내부 노드 삭제**: 서브트리 처리 방법 결정 필요

```c
node *delete(node *root, node *it, char direction) {
    node *parent = searchParent(root, it);
    if(parent == NULL) {
        printf("삭제 불가!\n");
        return NULL;
    } else {
        if(direction == 'l') {
            parent->left = NULL; 
            free(parent->left); 
            return it;
        }
        else if(direction == 'r') {
            parent->right = NULL; 
            free(parent->right); 
            return it;
        }
        else return NULL;
    }
}
```

### 5.3 이진 트리 노드 개수 세기

#### 전체 노드 개수
```c
int get_nodeNum(node *root) {
    int num = 0;
    if(root == NULL) {
        return 0;
    } else {
        num = 1;
        num += (get_nodeNum(root->left) + get_nodeNum(root->right));
        return num;
    }
}
```

#### 잎 노드 개수
```c
int get_leafNum(node *root) {
    int result = 0;
    if(root == NULL) {
        return 0;
    } else if (root->left == NULL && root->right == NULL) {
        return 1;
    }
    result += get_leafNum(root->left) + get_leafNum(root->right);
    return result;
}
```

## 6. 일반 트리를 이진 트리로 변환

이진 트리가 사용하기 편리하고 효율적이기 때문에 일반 트리를 이진 트리로 변환할 필요가 있다.

### 변환 방법
1. 먼저 주어진 일반 트리에서 형제들을 연결
2. 다음으로 각 노드에 대하여 가장 왼쪽 링크만 남기고 나머지는 모두 제거
3. 왼쪽으로 45도 회전

이 방법을 사용하면 다음과 같은 특징이 있다:
- 왼쪽 자식: 원래 트리에서의 첫 번째 자식
- 오른쪽 자식: 원래 트리에서의 다음 형제

## 핵심 개념 요약

1. 트리는 논리적 계층이 있는 구조
2. 노드 항목을 '노드(node)' 혹은 '정점(vertex)'이라고 함
3. 트리에서 루트는 부모를 갖지 않는 노드
4. 트리에 있는 어떤 노드에 대해 그 노드로 들어오는 선의 개수를 진입 차수, 나가는 선의 개수를 진출 차수라고 함
5. 트리에서 각 노드의 차수(degree of a node)는 진출 차수로 정의
6. 트리의 차수(degree of a tree)는 트리 내의 각 노드의 차수 가운데 최대 차수로 정의
7. 루트도 아니고 아닌 노드를 내부 노드라 하고, 같은 부모를 갖는 노드들을 형제(sibling)라고 함
8. 트리에서 각 노드의 레벨(level)은 루트로부터 그 노드까지 이어진 경로의 길이로 정의
9. 트리는 데이터의 계층 관계, 포함 관계 등을 나타내는 자료구조
10. 트리에 속한 모든 노드의 차수가 2 이하인 트리를 이진 트리라고 함
11. 이진 트리에서 모든 노드가 0 또는 2개의 자식을 가질 때 전(full) 이진 트리라고 함
12. 이진 트리에서 각 레벨이 허용되는 최대 개수 노드를 가질 때 그 트리를 가득 찬(perfect) 이진 트리라고 함
13. 높이가 k인 이진 트리가 레벨 0부터 k-2까지 다 채우고 마지막 k-1 레벨에서 왼쪽부터 오른쪽으로 노드들이 차례로 채워졌을 때 완전(complete) 이진 트리라고 함
14. 트리의 각 노드를 빠짐없이 한 번만 방문하는 것을 순회(traverse)라고 함
15. 루트를 방문하는 순서에 따라 각각 전위(preorder) 순회, 중위(inorder) 순회, 후위(postorder) 순회라고 구분하여 부름
