# 제 4장 큐

## 개관

큐는 스택과 유사하게 입출력 순서를 중요시하는 자료구조. 즉, 입출력 순서의 관리를 통해 입력이 가장 빠른 자료가 가장 먼저 출력되는 관계를 표현. 그렇기 때문에 큐는 줄을 서는 순서에 따라서 공평하게 서비스하는 경우에 많이 사용되고, 자원의 할당을 받으려는 작업들 간의 순서를 관리하기 위해 사용되는 경우가 많음.

큐의 입력 연산 시에는 수행 전에 정의된 큐의 크기와 저장된 데이터 확인이 필요하며, 큐의 크기보다 더 많은 자료를 입력하려 한다면 예외가 발생하기 때문. 그리고 큐의 출력 연산을 수행하기 전에 큐의 상태 검사가 필요. 큐에 원소가 하나도 없다면 삭제 연산은 수행 불가. 원형 큐는 큐의 빈 공간 활용도를 높이기 위해 제안되었으며, 큐에 비해서 '만원 상태'를 놓을 수 있는 자료구조.

## 학습목표

1. 큐의 추상 자료형 이해
2. 큐의 삽입 연산과 삭제 연산에 대한 이해
3. 큐를 이용한 CPU 할당 방법의 이해
4. 만원 상태를 놓을 수 있는 원형 큐의 이해

## 용어정리

- **큐(queue)**: 한쪽에서는 삽입이 발생하고 다른 한쪽에서는 삭제가 발생하도록 정의된 것으로, 먼저 삽입된 원소가 먼저 삭제되므로 선입선출(First-In-First-Out, FIFO) 또는 선착순 서브(First-Come-First-Serve, FCFS) 알고리즘과 함께 사용되는 자료구조
- **큐의 앞(front)**: 원소의 삭제 연산이 이루어지는 위치
- **큐의 뒤(rear)**: 원소의 삽입 연산이 이루어지는 위치
- **FCFS 스케줄링(또는 FIFO 스케줄링)**: 작업(프로그램)이 준비 큐에 도착한 순서대로 CPU를 할당받도록 하는 기법
- **RR(Round Robin) 스케줄링**: 작업(프로그램)이 도착한 순서대로 CPU가 할당되지만, CPU의 시간 할당량 또는 시간 간격에 의해 제한을 받으며, 일정한 크기의 시간 할당량을 모든 작업에 주고 그 시간 동안 작업이 완료되지 못하면 준비 큐의 뒤에 다시 배치되는 기법
- **원형 큐**: 파이프의 입구와 출구 부분을 연결시킨 형태이며, 큐의 양 끝을 연결시켜서 원으로 만든 형태의 큐

## 1. 큐의 개념

큐의 응용 분야는 일상생활에서 많이 볼 수 있는데, 택시를 타기 위해 서 있는 대기 줄, 병원의 접수대, 은행의 예금 인출기, 백화점의 계산대 위에 놓인 상품들이 좋은 예. 큐는 컴퓨터 시스템에서도 많이 사용됨. 운영체제는 우선순위에 따라 작업을 처리하기 위해 컴퓨터 시스템에 제출되는 작업에 대한 작업 스케줄을 작성.

큐는 가장 처음에 제출되어 작업 대기 줄에 들어간 작업이 가장 처음에 처리되는 작업 스케줄(First-In-First-Service)을 표현하는 자료구조. 스택과 비교해 보면 공정하다고 할 수 있음. 먼저 도착한 작업이 먼저 처리되기 때문.

스택은 한쪽 끝이 막힌 관과 같은 구조였음. 큐는 양쪽이 모두 뚫린 관이라고 생각할 수 있음. 즉, 양쪽이 개방되어 있기 때문에 삽입 연산과 삭제 연산이 양쪽에서 모두 일어날 수 있음. 하지만 양쪽에서 동시에 삽입과 삭제가 발생하면 복잡하기 때문에 삽입 연산과 삭제 연산이 일어나는 곳에 제한을 둠. 즉, 큐의 한쪽에는 삽입 연산만 발생하고, 다른 한쪽에는 삭제 연산만 발생하도록 제한.

이렇게 하면 훨씬 간단하고 명확해짐. 스택은 특정한 한쪽에서 삽입과 삭제가 동시에 발생하도록 정의되었으며, 큐는 한쪽에서는 삽입이 발생하고 다른 한쪽에서는 삭제가 발생하도록 정의됨. 큐는 스택과는 달리 큐에 가장 처음 입력된 원소가 가장 먼저 삭제되므로 선입선출(First-In-First-Out FIFO) 또는 선착순 서브(First-Come-First-Serve FCFS) 알고리즘과 함께 사용.

### 큐의 모습 예시

```
삽입(add) ← [D][C][B][A] ← 삭제(delete)
          rear  ↑    ↑  front
```

## 2. 큐의 추상 자료형

스택이 한쪽 끝에서만 원소의 삽입 연산과 삭제 연산이 동시에 가능한 것과는 달리 큐(queue)는 한쪽 끝에서는 원소의 삽입 연산만 가능하고 다른 한쪽 끝에서는 원소의 삭제 연산만 가능. 스택에서 원소의 삽입 연산과 삭제 연산이 발생되는 곳을 'top'이라고 지정했던 것과 같이, 큐에서는 원소의 삭제 연산이 이루어지는 곳을 '앞(front)'이라 하고 삽입 연산이 이루어지는 곳을 '뒤(rear)'라고 명명.

큐의 추상 자료형 검토 시, 큐의 추상 자료구조는 '객체 정의'와 '연산자'로 구성. 일반적으로 큐에서 기본적으로 사용되는 연산은 큐에 원소를 삽입하는 Add_q(insert_q)와 큐에서 원소를 삭제하는 Delete_q가 존재.

### 큐의 기본 연산

1. **Add_q(insert_q)**: 큐에 원소를 삽입하는 연산
2. **Delete_q**: 큐에서 원소를 삭제하는 연산
3. **IsFull_q**: 큐가 가득 찬 상태인지 검사하는 연산
4. **IsEmpty_q**: 큐가 빈 상태인지 검사하는 연산

### 큐의 추상자료형

**객체**: 0개 이상의 유한 순서 리스트

**연산**: queue∈Queue, item∈element, maxQueueSize∈positive integer에 대하여 다음과 같은 연산이 정의됨 (queue는 0개 이상의 원소를 갖는 큐, item은 큐에 삽입되는 원소, maxQueueSize는 큐의 최대 크기를 정의하는 정수).

1. **Queue Create_q(maxQueueSize)** ::=  
   큐의 크기가 maxStackSize인 빈 큐를 생성하고 반환;

2. **Boolean IsFull_q(queue, maxQueueSize)** ::=  
   ```
   if((queue의 elements의 개수) == maxQueueSize)
   then { 'TRUE' 값을 반환; }
   else { 'FALSE' 값을 반환; }
   ```

3. **Queue Add_q(queue, item)** ::=  
   ```
   if(IsFull_q(queue))
   then { 'queueFull' 메시지를 출력; }
   else { rear에서 item을 삽입하고, 큐를 반환; }
   ```

4. **Boolean IsEmpty_q(queue)** ::=  
   ```
   if(rear == front)
   then { 'TRUE' 값을 반환; }
   else { 'FALSE' 값을 반환; }
   ```

5. **Element Delete_q(queue)** ::=  
   ```
   if(IsEmpty_q(queue))
   then { 'queueEmpty' 메시지를 출력; }
   else { 큐의 front에 있는 원소(element)를 삭제하고 반환; }
   ```

<details>
<summary>큐의 삽입/삭제 연산 과정 예시</summary>

```
1. Create_q(4);
2. Add_q(queue, 'A');
3. Add_q(queue, 'B');
4. Add_q(queue, 'C');
5. Delete_q(queue);
6. Delete_q(queue);
7. Delete_q(queue);
8. Add_q(queue, 'D');
```

큐가 생성되고 'A', 'B', 'C'를 순서대로 삽입한 후 Delete_q 연산을 3번 수행하면 'A', 'B', 'C' 순서로 삭제됨. 이후 'D'를 삽입할 수 있음. 큐의 FIFO(First-In-First-Out) 특성에 따라 먼저 삽입된 원소가 먼저 삭제됨.

</details>

## 3. 큐의 응용

중앙처리장치(CPU)는 컴퓨터 자원 중에서 아주 중요한 자원. 특히 많은 프로그램이 CPU를 할당받기 위해 줄을 서서 대기. 따라서 CPU의 효율적 관리 시 프로그램이 빨리 실행되고 전체 컴퓨터의 처리 시간도 단축.

### FCFS(First-Come-First-Served) 스케줄링

FCFS 스케줄링 기법(또는 FIFO 스케줄링)은 작업(프로그램)이 준비 큐에 도착한 순서대로 CPU를 할당받도록 하는 기법. 일단 하나의 작업이 CPU를 차지하면 그 작업의 수행이 완료된 후에 다음 작업에 CPU를 할당.

**특징:**
- 처음 도착한 작업이 처음 CPU를 할당받도록 하는 기법
- 공정한 처리 순서 보장

**단점:**
- 긴 작업 때문에 짧은 작업이 오래 대기할 수 있는 문제
- 중요한 프로세스가 덜 중요한 작업의 완료를 기다리는 경우 발생

### RR(Round Robin) 스케줄링

RR 스케줄링 기법은 대화형 시스템에 사용되는 스케줄링 방식. 작업이 도착한 순서대로 CPU가 할당되지만, CPU의 시간 할당량 또는 시간 간격에 의해 제한을 받음.

**특징:**
- 일정한 크기의 시간 할당량을 모든 작업에 부여
- 시간 내 완료되지 못한 작업은 준비 큐의 뒤로 이동
- 그다음 준비 큐에 있는 다음 작업에 CPU 할당

**장점:**
- 작업이 CPU를 독점하지 않고 공평한 CPU 사용

**단점:**
- 우선순위가 높은 작업의 빠른 처리가 어려운 문제

## 4. 배열을 이용한 큐의 구현

1차원 배열을 이용한 큐 구현. 큐의 크기를 5로 정하고 제한된 공간에서 데이터를 삽입(Add_q)하고 삭제(Delete_q).

### 큐의 생성

```c
#define QUEUE_SIZE 5
typedef int element;
element queue[QUEUE_SIZE];
int front = -1;
int rear = -1;
```

큐 생성의 의미:

1. 큐의 크기(QUEUE_SIZE)를 5로 정의
2. 큐의 원소인 element를 int형으로 정의
3. 자료형 element를 저장할 수 있는 큐를 큐의 크기만큼 할당
4. rear와 front는 전역변수로 정의되고, 큐의 삽입이 발생하는 rear와 삭제가 발생하는 front의 초깃값을 -1로 저장하여 공백 상태로 초기화

### 4.1. 큐의 삽입 연산

삽입 연산이 발생하면 rear 변수만 오른쪽으로 이동하고, 삭제 연산이 발생하면 front 변수만 오른쪽으로 이동.

```c
void Add_q(element item) {
    if(rear == QUEUE_SIZE-1) {
        printf("Queue is full !!");
        return;
    }
    queue[++rear] = item;
    return;
}
```

**삽입 연산 과정:**
1. rear 값이 QUEUE_SIZE-1과 같은지 검사 (만원 상태 확인)
2. 만원이라면 "Queue is full !!" 메시지 출력
3. 만원이 아니라면 rear 값을 1 증가시키고 해당 위치에 item 삽입

### 4.2. 큐의 삭제 연산

삭제 연산의 수행 결과로 삭제된 원소를 Delete_q를 호출한 메인 프로그램에 반환.

```c
element Delete_q() {
    if(front == rear) {
        printf("Queue is empty");
        return; 
    }
    return(queue[++front]);
}
```

**삭제 연산 과정:**
1. front와 rear 값이 같은지 검사 (빈 상태 확인)
2. 빈 상태라면 "Queue is empty" 메시지 출력
3. 빈 상태가 아니라면 front 값을 1 증가시키고 해당 위치의 원소 반환

## 5. 원형 큐

큐에 원소 하나를 삽입하면 rear 값이 증가하고, 삭제를 하면 front 값이 증가. 이렇게 rear 값이 배열의 끝에 도달하면 앞쪽에 빈 공간이 있어도 더 이상 삽입이 불가능.

**선형 큐의 문제점:**
- 배열로 구현된 큐에서는 rear 값이 배열의 끝에 도달하면 앞쪽에 빈 공간이 있어도 삽입이 불가능
- 메모리 공간의 비효율적 사용

### 원형 큐의 개념

이러한 문제점을 해결하기 위한 원형 큐 제안. 원형 큐는 파이프의 입구와 출구 부분을 연결시킨 형태. 자료구조의 관점에서 설명하면, 배열의 끝과 처음을 연결하여 원형으로 만든 구조로, 빈 공간을 효율적으로 활용 가능.

### 원형 큐의 구현

고려해야 할 부분은 rear의 위치를 'n-1'에서 '0'으로 변경하는 방법. 

원형 큐에서는 다음과 같은 연산식을 사용:
- **rear 값의 증가**: rear ← (rear+1) mod n
- **front 값의 증가**: front ← (front+1) mod n

**mod 연산자 활용 예시:**
- rear가 3인 상태에서 삽입: (3+1) mod 5 = 4
- rear가 4인 상태에서 삽입: (4+1) mod 5 = 0

이렇게 하면 '나머지 연산자'를 이용하여 배열의 앞부분을 재사용할 수 있게 됨. 작은 메모리를 활용하여 메모리 활용도를 높인 구조.

## Summary | 요약

1. 큐는 한쪽에서는 삽입이 발생하고 다른 한쪽에서는 삭제가 발생하도록 정의되었으며, 먼저 삽입된 원소가 먼저 삭제되므로 선입선출(First-In-First-Out, FIFO) 또는 선착순 서브(First-Come-First-Serve, FCFS) 알고리즘과 함께 사용되는 자료구조.

2. 큐에서는 원소의 삭제 연산이 이루어지는 곳을 앞(front)이라 하고, 삽입 연산이 이루어지는 곳을 뒤(rear)라고 명명.

3. 큐 생성 함수인 Create_q(maxQueueSize) 호출만으로 프로그래머가 지정한 크기의 새로운 큐를 생성 가능. Create_q(maxQueueSize) 함수의 매개변수인 maxQueueSize는 큐가 저장할 수 있는 최대 개수의 원소(element)를 의미.

4. Boolean IsFull_q(queue, maxQueueSize) 연산은 큐가 '만원(full)' 상태인지를 확인. 즉, 큐에 저장된 원소(element)의 개수가 maxQueueSize와 같다면, 그 큐는 '만원(full)' 상태이며 큐에 자료(원소)를 더 이상 저장할 수 없다는 것을 의미.

5. Queue Add_q(queue, item) 연산은 큐에 새로운 원소를 삽입. 만일 큐가 가득 찼다(full)면 더 이상의 원소를 큐에 삽입할 수 없으며, 'queueFull' 메시지를 출력.

6. Boolean IsEmpty(queue) 연산은 큐 상태가 빈 상태인지를 확인. 만일 큐가 빈 상태이면 'TRUE' 값을 반환하고, 큐에 하나 이상의 원소라도 있다면 'FALSE' 값을 반환.

7. Element Delete_q(queue) 연산자는 큐가 빈 상태라면 삭제할 원소가 없으므로 'queueEmpty'를 출력. 하지만 빈 상태가 아니라면 삭제할 원소가 있으므로, 큐의 front가 가리키는 원소를 삭제하고 그 원소를 반환.

8. 큐의 추상 자료형에서 정의된 연산은 시스템 개발자에 따라 다르게 정의되고 구현될 수도 있고, 컴퓨터 설계자에 따라 프로그래밍 언어에서 다르게 제공될 수도 있음.

9. 원형 큐는 파이프의 입구와 출구 부분을 연결시킨 형태이며, 연결된 부분의 데이터 공간을 연속적으로 사용하기 위해 '나머지 연산자(mod)' 사용.
