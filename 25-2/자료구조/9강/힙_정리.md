# 9장 힙 (Heap)

## 개관

힙은 부분적으로 정렬된 완전 이진 트리 형태이며, 부모 노드와 자식 노드 간의 관계를 노드 간의 크기에 의해 정의한다. 노드 간의 관계에서 부모 노드가 자식 노드보다 크면 최대힙이라고 하고, 부모 노드가 자식보다 작으면 최소힙이라 한다. 노드를 삭제하거나 삽입하는 경우에는 완전 이진 트리 형태를 유지해야 하며, 노드 사이의 대소관계도 갖추어야 한다. 즉, 완전 이진 트리의 조건과 노드의 대소관계, 노드의 삭제 연산과 삽입 연산을 구현해야 한다.

## 학습 목표

1. 힙의 정의를 이해한다
2. 힙의 구성 방법을 이해하고, 힙의 노드 삽입 연산과 삭제 연산을 이해한다
3. 최대힙과 최소힙을 이해한다

## 용어 정리

- **힙(heap)**: 부모 노드와 자식 노드 사이에 일정한 대소관계를 정의하여 구성한 완전 이진 트리이며 우선순위 큐와 같음
- **최대힙**: 루트가 가장 큰 값을 갖고 부모는 자식보다 큰 값을 갖는 완전 이진 트리
- **최소힙**: 루트가 가장 작은 값을 갖고 부모는 자식보다 작은 값을 갖는 완전 이진 트리

---

## 1. 우선순위 큐

### 큐의 기본 개념

**큐**: 먼저 들어간 데이터가 먼저 삭제되는 자료구조
- 먼저 줄을 선 사람이 먼저 서비스를 받는 구조

### 우선순위 큐의 개념

**우선순위 큐**: 대기 리스트에서 우선순위가 높은 사람이 먼저 서비스를 받는 구조

피라미드 모양으로 쌓아 올린 더미를 힙(heap)이라 한다. 또는 히프라고도 한다. 무엇인가를 쌓아놓은 더미이고 항상 가장 위에 있는 것을 우선 꺼내는 구조를 상징한다.

### 준비 큐(Ready Queue)의 예시

운영체제에서 CPU 스케줄링에 사용되는 준비 큐는 우선순위 큐의 대표적인 예시다:
- 프로세스 A, C, B가 준비 큐에 대기 중일 때
- 우선순위가 높은 프로세스부터 CPU에 할당됨

### 우선순위 큐의 배열 구현 문제점

배열을 이용한 힙의 구현 시 발생하는 문제:
1. **첫째**, 삭제 명령이 실행되면 저장된 데이터 중에서 가장 작은 값(가장 큰 값)이 삭제된다
2. **둘째**, 나머지 데이터들은 어떤 순서로 저장되는 문제가 되지 않는다
3. 데이터 삭제 때는 n번째 데이터를 첫 번째로 이동시켜야 함

**우선순위 큐의 작동 방식**:
- Delete_q()에 의해 큐의 front에 있던 '1'이 삭제되면서, 나머지 데이터 중에서 가장 작은 값인 '2'가 다음 삭제 위치가 됨
- front가 가리키는 위치로 이동됨

---

## 2. 힙 추상 자료형

힙은 우선순위 큐의 한 종류다. 우선순위 큐의 작동 방법은 정의하였지만 그것을 어떻게 구현해야 하는지는 정해지지 않았다. 우선순위 큐를 트리로 구현할 때 바로 힙이다. 트리로 구현하되 부모와 자식 노드 사이에 일정한 대소관계를 유지해야 하는 조건이 추가된다.

힙의 추상 자료형은 다음과 같다:

### 힙의 추상 자료형

**힙 객체의 정의**: 부분적으로 정렬된 완전 이진 트리로 부모 노드는 자식 노드보다 우선순위가 높음

**연산**:
1. `insert(element)` := 힙에 데이터 삽입
2. `delete()` := 힙(루트)에서 데이터 삭제
3. `peek()` := 힙(루트)에서 데이터 읽어 오기
4. `isEmpty()` := 힙이 비었는지 확인
5. `size()` := 힙에 저장한 데이터 개수 확인

부분적으로 정렬되었다는 것은 전체가 1열로 정렬되지는 않았다는 의미다. 즉, 트리 전체가 루트로부터 아래로 차례대로 배치되지 않았다는 뜻이다.

---

## 3. 최소힙과 최대힙

먼저 최소힙과 최대힙을 소개하고 부분적으로 정렬되었다는 의미를 다시 생각해보자.

### 최소힙과 최대힙의 특징

- **최소힙**: 루트가 최소값이고 모든 부모 노드가 자식 노드보다 작은 값을 갖는 완전 이진 트리
- **최대힙**: 루트가 최대값이고 모든 부모 노드가 자식 노드보다 큰 값을 갖는 완전 이진 트리

두 트리 모두 완전 이진 트리임을 먼저 확인하자. 다음으로 최소힙은 루트가 최소값이고 최대힙은 최대값임을 확인할 수 있다. 그리고 트리의 모든 노드가 자식 노드보다 작은(큰) 값을 갖는다는 것을 알 수 있다. 그러나 트리의 레벨에 따라 데이터가 순서를 갖지는 않는다. 또한 다음에 배울 BST 트리처럼 왼쪽, 오른쪽 노드 사이에 크기 조건도 없다. 힙은 딱 두 가지, 즉 루트가 가장 작은(큰) 값을 갖고 부모는 자식보다 작은(큰) 값을 가지면 된다.

---

## 4. 힙에서 삭제 및 삽입 연산

이제 힙에서 삭제 및 삽입 연산에 대해 알아보자. 먼저 힙을 구현해야 하므로 배열로 구현하여 메모리를 효율적으로 활용하겠다.

### 배열을 이용한 힙의 구현

배열을 이용한 힙의 구현: 완전 이진 트리이기 때문에 배열로 구현해도 기억장소 낭비가 없음
- **연결 리스트보다 실행 속도 면에서 효율적임**
- **기억장소 측면에서도 장점을 가짐**

#### 힙의 배열 구현 예시

```
트리 구조:
         1
       /   \
      15    5
     / \   / \
    20 16  10 19
   /\ /\  /\
  25 30 17 18 12 23

배열 표현:
인덱스: 0  1  2  3  4  5  6  7  8  9 10 11 12 13 ...
데이터: -  1 15  5 20 16 10 19 25 30 17 18 12 23 ...
```

배열 인덱스 관계식:
- 왼쪽 자식 노드의 인덱스: `i*2`
- 오른쪽 자식 노드의 인덱스: `i*2+1`
- 부모 노드의 인덱스: `i/2`

**주의**: 인덱스는 0이 아닌 1부터 사용한다!

---

### 힙의 삭제 연산 단계별 설명

#### 삭제 알고리즘의 과정

1. **루트 노드 삭제**: 힙에서 삭제(루트에서 삭제)
   - `data = h->heap[1]`: 루트 값을 data에 저장
   - `temp = h->heap[(h->size)--]`: 마지막 노드를 temp에 저장하고 크기 감소
   - `parent = 1; child = 2`: 루트부터 시작

2. **마지막 노드를 루트로 이동**
   - 마지막 노드(23)를 루트 위치로 임시 이동
   - 완전 이진 트리 형태 유지

3. **힙 속성 복원을 위한 비교와 교환**
   ```c
   // 더 작은 자식 선택
   if((child < h->size) && (h->heap[child] > h->heap[child+1])) {
       child++;
   }
   
   // temp가 자식보다 작거나 같으면 종료
   if(temp <= h->heap[child]) {
       break;
   }
   
   // 자식을 부모 위치로 이동
   h->heap[parent] = h->heap[child];
   parent = child;
   child *= 2;
   ```

4. **적절한 위치에 temp 배치**
   - `h->heap[parent] = temp`: 최종 위치에 temp 저장
   - `return data`: 삭제된 루트 값 반환

#### 삭제 연산의 구체적 예시 (23 삭제 과정)

1. 루트 1을 삭제하고 마지막 노드 23을 temp에 저장
2. 5와 15 중 더 작은 5를 선택
3. temp(23) > 5이므로 5를 루트로 이동
4. 10과 19 중 더 작은 10을 선택  
5. temp(23) > 10이므로 10을 위로 이동
6. 12와 23 비교 후 temp(23) > 12이므로 12를 위로 이동
7. 최종적으로 temp(23)을 적절한 위치에 배치

#### 삭제 연산 코드

```c
typedef struct heap {
    int heap[MAX_SIZE];
    int size;
} heap;

int min_heapDelete(heap* h) {
    int parent, child;
    int data, temp;
    
    data = h->heap[1];  // 루트 값 저장
    temp = h->heap[(h->size)--];  // 마지막 노드 값
    parent = 1; 
    child = 2;
    
    while(child <= h->size) {
        // 더 작은 자식 선택
        if((child < h->size) && (h->heap[child] > h->heap[child + 1])) {
            child++;
        }
        
        // temp가 자식보다 작거나 같으면 종료
        if(temp <= h->heap[child]) {
            break;
        }
        
        // 자식을 부모 위치로 이동
        h->heap[parent] = h->heap[child];
        parent = child;
        child *= 2;
    }
    
    h->heap[parent] = temp;  // temp를 적절한 위치에 저장
    return data;
}
```

### 힙의 삽입 연산 단계별 설명

#### 삽입 알고리즘의 과정

삽입 연산은 삭제보다 간단하다. 새로운 데이터를 힙에 삽입하는 알고리즘이다.

1. **마지막에 노드 삽입**: 새로운 요소를 완전 이진 트리의 마지막 위치에 삽입
   - `i = ++(h->size)`: 힙 크기를 증가시키고 새 위치 설정

2. **상향 이동을 통한 힙 속성 복원**: 
   ```c
   while((i != 1) && (data < h->heap[i/2])) {
       h->heap[i] = h->heap[i/2];  // 부모를 아래로 이동
       i /= 2;  // 부모 위치로 이동
   }
   ```

3. **최종 위치에 데이터 저장**: `h->heap[i] = data`

#### 삽입 연산의 구체적 예시 (7과 12 교환 과정)

**7 삽입 과정**:
1. 마지막 위치에 7 삽입
2. 부모 12와 비교: 7 < 12이므로 7과 12 교환
3. 새 부모 10과 비교: 7 < 10이므로 7과 10 교환  
4. 새 부모 5와 비교: 7 > 5이므로 종료
5. 최종 위치에 7 저장

**배열 표현 변화**:
- 삽입 전: `[5, 15, 10, 20, 16, 12, 19, 25, 30, 17, 18, 23, 7]`
- 삽입 후: `[5, 15, 7, 20, 16, 10, 19, 25, 30, 17, 18, 23, 12]`

#### 삽입 연산 코드

```c
void min_heapInsert(heap *h, int data) {
    int i;
    i = ++(h->size);
    
    while((i != 1) && (data < h->heap[i/2])) {
        h->heap[i] = h->heap[i/2];  // 부모를 아래로 이동
        i /= 2;  // 부모 위치로 이동
    }
    
    h->heap[i] = data;  // 데이터 삽입
}
```

### 힙이 아닌 경우

다음과 같은 경우들은 힙의 조건을 만족하지 않는다:

#### 완전 이진 트리가 아님
- 트리의 구조가 완전 이진 트리 형태를 갖지 않는 경우

#### 부모 노드와 자식 노드의 대소관계 위배
- 부모 노드가 자식 노드보다 작지 않음 (최소힙의 경우)
- 부모 노드가 자식 노드보다 크지 않음 (최대힙의 경우)

### 힙과 이진 트리의 차이

힙과 일반 이진 트리의 주요 차이점:
- **힙**: 완전 이진 트리 + 부모와 자식 간 대소관계 조건
- **이진 트리**: 단순히 각 노드가 최대 2개의 자식을 갖는 트리

### 시간복잡도

- **삭제 연산**: O(log n) - 트리의 높이만큼 비교
- **삽입 연산**: O(log n) - 트리의 높이만큼 비교

힙은 완전 이진 트리이므로 높이가 log₂n이 되어 매우 효율적이다.

---

## Summary 요약

1. 힙은 무엇인가를 쌓아 놓은 더미이고, 항상 가장 위에 있는 것을 우선하여 꺼내는 구조를 상징한다. 그리고 힙은 우선순위 큐의 한 종류다.

2. 힙은 완전 이진 트리이며, 최소힙은 루트가 최소값이고 최대힙은 최대값이다.

3. 최대힙은 트리의 모든 노드가 자식 노드보다 큰 값을 갖는 것이다.

4. 최소힙은 트리의 모든 노드가 자식 노드보다 작은 값을 갖는 것이다.

5. 힙에서 노드를 삭제한 후에도 완전 이진 트리이어야 하며, 최대힙 혹은 최소힙의 조건을 만족해야 한다.

### 정리하기

**힙(heap)**: 부모노드와 자식노드 사이에 일정한 대소관계를 정의하여 구성한 완전 이진 트리이며 우선순위 큐와 같음

**최대힙**: 루트가 가장 큰 값을 갖고 부모는 자식보다 큰 값을 갖는 완전 이진 트리

**최소힙**: 루트가 가장 작은 값을 갖고 부모는 자식보다 작은 값을 갖는 완전 이진 트리

---

**참고**: 이 정리는 제9장 힙에 대한 핵심 내용을 담고 있으며, 실제 구현과 알고리즘의 세부사항을 포함한다.
