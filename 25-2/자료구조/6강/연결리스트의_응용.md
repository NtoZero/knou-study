# 6장 연결 리스트의 응용

## 1. 연결 리스트의 변형

연결 리스트는 **단순 연결 리스트(singly linked list)**, **이중 연결 리스트(doubly linked list)**, **원형 연결 리스트(circular linked list)**로 변형할 수 있다.

### 연결 리스트 종류별 특징 및 구조

1. **단순 연결 리스트**
   ```
   H → head → [data|Rlink] → [data|Rlink] → [data|Rlink] → NULL
   ```
   - 각 노드는 후행 노드만을 가리키는 구조
   - **문제점**: 특정 노드의 선행 노드에 대한 접근은 헤드 노드부터 재검색해야 함
   - **복잡성**: 어떤 특정 노드의 선행 노드를 찾으려면 헤드부터 순차 탐색하는 복잡한 방법이 필요

2. **이중 연결 리스트**
   ```
   H → Lhead/Fhead ⇄ [Llink|data|Rlink] ⇄ [Llink|data|Rlink] ⇄ [Llink|data|Rlink]
   ```
   - 양방향 링크(Llink, Rlink)로 선행/후행 노드 모두 직접 접근 가능
   - 특정 노드에서 선행 노드와 후행 노드에 대해 간단한 프로그램 코드로 접근할 수 있는 구조
   - **성능 이점**: O(1) 시간에 양방향 이동 가능

3. **원형 연결 리스트**
   ```
   H → head → [data|link] → [data|link] → [data|link] ⤴
               ⬇_________________________⬆
   ```
   - 마지막 노드의 링크 부분이 첫 번째 노드를 가리켜 원형 연결 구조
   - NULL 값을 갖는 마지막 노드의 링크 부분을 활용하면서도 프로그램 성능에 도움
   - **장점**: 한 노드로부터 다른 모든 노드로 접근 가능, 순환 처리에 효율적

## 2. 원형 연결 리스트

원형 연결 리스트는 가장 마지막 노드의 링크가 연결 리스트의 마지막 원소가 아닌 첫 번째 노드를 가리켜 리스트의 구조를 원형으로 만든 것이다.

### 2.1. 원형 연결 리스트의 생성

원형 연결 리스트에서는 마지막 노드가 리스트의 첫 번째 노드를 가리키게 하여 리스트의 구조를 원형으로 만든다.

<details>
<summary>노드 구조 정의</summary>

```c
typedef struct ListNode { // 연결 리스트의 노드 구조 정의
    int data;
    struct ListNode* link;
} listNode;

typedef struct { // 헤드 노드 구조 정의
    listNode* head;
} linkedList_h;

linkedList_h* createLinkedList_h(void) { // 원형 연결 리스트의 헤드 노드 생성
    linkedList_h* H;
    H = (linkedList_h*)malloc(sizeof(linkedList_h));
    H->head = NULL;
    return H;
}
```
</details>

### 2.2. 원형 연결 리스트의 노드 삽입(1) - 첫 번째 노드 삽입

첫 번째 노드를 삽입하는 연산을 구현한다. 원형 연결 리스트의 특성상 두 가지 경우를 고려해야 한다.

<details>
<summary>첫 번째 노드 삽입 코드</summary>

```c
void addFirstNode(linkedList_h* H, int x) {
    // 원형 연결 리스트 첫 번째 노드 삽입, x값은 100이라고 가정함
    listNode* tempNode;
    listNode* NewNode;
    NewNode = (listNode*)malloc(sizeof(listNode));
    NewNode->data = x;
    NewNode->link = NULL;
    
    if(H->head == NULL) { // 현재 리스트가 공백인 경우
        H->head = NewNode;
        NewNode->link = NewNode; // 자기 자신을 가리켜 원형 구조 형성
        return;
    }
    else { // 현재 리스트가 공백이 아닌 경우
        tempNode = H->head;
        // 마지막 노드를 찾기 위한 순회 (마지막 노드의 link가 head를 가리킴)
        while(tempNode->link != H->head) 
            tempNode = tempNode->link;
        
        NewNode->link = tempNode->link;  // 새 노드가 첫 번째 노드를 가리킴
        tempNode->link = NewNode;        // 마지막 노드가 새 노드를 가리킴
        H->head = NewNode;               // 헤드가 새 노드를 가리킴
    }
}
```
</details>

**삽입 과정의 상세 단계**:

1. **공백 리스트인 경우**:
   - 새 노드 생성 및 데이터 저장
   - H->head = NewNode
   - NewNode->link = NewNode (자기 자신을 가리켜 원형 구조 완성)

2. **공백이 아닌 경우**:
   - 새 노드 생성 및 데이터 저장
   - 현재 마지막 노드를 탐색 (tempNode->link == H->head인 노드)
   - 새 노드의 링크를 현재 첫 번째 노드로 설정
   - 마지막 노드의 링크를 새 노드로 변경
   - 헤드를 새 노드로 업데이트

### 2.3. 원형 연결 리스트의 노드 삽입(2) - 중간 노드 삽입

중간 노드로 삽입하는 연산이다. 앞에서 학습한 연결 리스트의 특정 노드 뒤에 삽입하는 과정과 동일하다.

<details>
<summary>중간 노드 삽입 코드</summary>

```c
void addMiddleNode(linkedList_h* H, listNode* prevNode, int itdata) {
    // 원형 연결 리스트 중간 노드로 삽입, itdata는 110이라고 가정함
    listNode* NewNode;
    NewNode = (listNode*)malloc(sizeof(listNode));
    NewNode->data = itdata;
    NewNode->link = NULL;
    
    // 삽입 과정
    NewNode->link = prevNode->link;  // 새 노드가 이전 노드의 다음 노드를 가리킴
    prevNode->link = NewNode;        // 이전 노드가 새 노드를 가리킴
    return;
}
```
</details>

**중간 삽입의 특징**:
- 원형 구조이므로 마지막 노드 뒤에 삽입해도 동일한 방식 적용
- prevNode가 마지막 노드인 경우, NewNode->link는 헤드 노드를 가리키게 됨

### 2.4. 원형 연결 리스트의 노드 삭제

원형 연결 리스트에서 노드를 삭제하는 연산이다. 여러 개의 노드가 있는 가운데 원하는 데이터 값을 가진 노드를 삭제하고자 한다.

<details>
<summary>노드 삭제 탐색 코드</summary>

```c
void finddelCircularNode(linkedList_h* H, int itdata) {
    // 원형 연결 리스트에서 삭제하려는 노드를 탐색하는 연산 (itdata=90)
    listNode* tempNode;
    listNode* prevNode;
    prevNode = H;
    
    if(H->head == NULL) { // 공백인 경우
        printf("Circular Linked List is EMPTY");
        return;
    }
    else {
        tempNode = H->head; // 첫 번째 노드부터 검색하기 위함
        do {
            if(tempNode->data == itdata) { // 찾는 노드값 검색
                return deleteCircularNode(H, prevNode);
            }
            else {
                prevNode = tempNode;
                tempNode = tempNode->link;
            }
        } while(tempNode != H->head); // 원형이므로 헤드까지 돌아오면 종료
    }
    // 마지막 노드까지 검색했는데 없는 경우라면,
    printf("Search Fail"); // 검색 실패 메시지 출력
    return;
}
```
</details>

<details>
<summary>실제 삭제 연산 코드</summary>

```c
void deleteCircularNode(linkedList_h* H, listNode* prevNode) {
    // 원형 연결 리스트에서 데이터의 값이 90인 노드(delNode)를 삭제하는 연산
    listNode* lastNode;
    listNode* delNode;
    
    // 마지막 노드를 찾음 (헤드를 가리키는 노드)
    lastNode = H->head;
    while(lastNode->link != H->head) 
        lastNode = lastNode->link;
    
    delNode = prevNode->link;        // 삭제할 노드
    prevNode->link = delNode->link;  // 이전 노드가 삭제 노드의 다음을 가리킴
    
    // 삭제할 노드가 헤드 노드인 경우, 마지막 노드의 링크 조정 필요
    if (delNode == H->head) {
        if (delNode->link == delNode) { // 노드가 하나뿐인 경우
            H->head = NULL;
        } else {
            lastNode->link = H->head; // 마지막 노드가 새로운 헤드를 가리킴
        }
    }
    
    free(delNode);
}
```
</details>

**원형 연결 리스트 삭제의 특별 고려사항**:
1. **일반 노드 삭제**: 이전 노드의 링크만 조정
2. **헤드 노드 삭제**: 마지막 노드의 링크도 새로운 헤드로 조정 필요
3. **마지막 노드 삭제**: 삭제 후에도 원형 구조 유지 확인

## 3. 이중 연결 리스트

단순 연결 리스트는 단방향의 링크를 가지고 있다. 단방향 링크를 가지는 리스트는 배열을 이용한 리스트의 구현 방법에 비하여 유연한 자료구조이며, 메모리 활용과 사용에 비해서도 충분히 효과적이고 유리한 면이 많다. 하지만 **어떤 특정 노드의 선행 노드를 찾으려면 복잡한 방법이 필요**하다는 단점이 있다.

### 3.1. 이중 연결 리스트의 노드 구조

이중 연결 리스트에서는 양쪽 방향으로 순회할 수 있도록 링크가 두 개 필요하다. 또한 시작점(head)도 두 개의 링크(Lhead, Fhead)가 필요하다.

<details>
<summary>이중 연결 리스트 노드 구조</summary>

```c
typedef struct ListNode { // 이중 연결 리스트의 노드 구조 정의
    struct ListNode* Llink;  // 좌측(선행) 노드를 가리키는 링크
    int data;                // 데이터 필드
    struct ListNode* Rlink;  // 우측(후행) 노드를 가리키는 링크
} listNode;

typedef struct { // 이중 연결 리스트의 헤드 노드 구조 정의
    listNode* Lhead;  // 마지막(Last) 노드를 가리키는 포인터
    listNode* Fhead;  // 첫 번째(First) 노드를 가리키는 포인터
} linkedList_h;

linkedList_h* createLinkedList_h(void) { // 이중 연결 리스트의 헤드 노드 생성
    linkedList_h* H;
    H = (linkedList_h*)malloc(sizeof(linkedList_h));
    H->Lhead = NULL;  // 초기에는 마지막 노드 없음
    H->Fhead = NULL;  // 초기에는 첫 번째 노드 없음
    return H;
}
```
</details>

**구조 요소의 상세 설명**:
- **Llink**: 선행 노드를 연결하는 포인터 (Left Link)
- **data**: 데이터 필드
- **Rlink**: 후행 노드를 가리키도록 하는 포인터 (Right Link)
- **Lhead**: 리스트의 마지막 노드를 가리키는 헤드 포인터
- **Fhead**: 리스트의 첫 번째 노드를 가리키는 헤드 포인터

**이중 헤드의 필요성**:
- 양방향 순회를 위해 시작점과 끝점을 모두 알아야 함
- 앞에서부터의 순회: Fhead → Rlink 방향
- 뒤에서부터의 순회: Lhead → Llink 방향

### 3.2. 이중 연결 리스트의 노드 삽입

이중 연결 리스트에서 중간 노드로 삽입하는 연산을 설명한다. 4개의 링크 연결을 모두 조정해야 한다.

<details>
<summary>이중 연결 리스트 삽입 코드</summary>

```c
void addDNode(linkedList_h* H, listNode* prevNode, int x) {
    // 이중 연결 리스트 노드 삽입 연산, x값은 200이라고 가정함
    listNode* NewNode;
    NewNode = (listNode*)malloc(sizeof(listNode));
    NewNode->Llink = NULL;
    NewNode->data = x;
    NewNode->Rlink = NULL;
    
    // 4단계 링크 연결 과정
    NewNode->Rlink = prevNode->Rlink;  // ① 새 노드의 Rlink를 이전 노드의 다음으로
    prevNode->Rlink = NewNode;         // ② 이전 노드의 Rlink를 새 노드로
    NewNode->Llink = prevNode;         // ③ 새 노드의 Llink를 이전 노드로
    NewNode->Rlink->Llink = NewNode;   // ④ 다음 노드의 Llink를 새 노드로
}
```
</details>

**삽입 과정의 상세 단계**:
```
삽입 전: prevNode ⇄ nextNode
삽입 후: prevNode ⇄ NewNode ⇄ nextNode
```

1. **① NewNode→Rlink = prevNode→Rlink**: 새 노드가 다음 노드를 가리킴
2. **② prevNode→Rlink = NewNode**: 이전 노드가 새 노드를 가리킴
3. **③ NewNode→Llink = prevNode**: 새 노드가 이전 노드를 가리킴
4. **④ NewNode→Rlink→Llink = NewNode**: 다음 노드가 새 노드를 가리킴

**주의사항**: 링크 연결 순서가 중요함. ①→②→③→④ 순서를 지켜야 기존 연결이 끊어지지 않음.

### 3.3. 이중 연결 리스트의 노드 삭제

이중 연결 리스트에서 여러 개의 노드가 존재하는 가운데 원하는 데이터 값을 가진 노드를 삭제하는 방법을 알아본다.

<details>
<summary>이중 연결 리스트 삭제 코드</summary>

```c
void deleteDNode(linkedList_h* H, listNode* delNode) {
    // 이중 연결 리스트에서 데이터의 값이 300인 노드(delNode)를 삭제하는 연산
    
    // 경계 조건 확인
    if (delNode->Llink != NULL) {
        delNode->Llink->Rlink = delNode->Rlink;  // 이전 노드의 Rlink 조정
    } else {
        H->Fhead = delNode->Rlink;  // 첫 번째 노드 삭제 시 헤드 조정
    }
    
    if (delNode->Rlink != NULL) {
        delNode->Rlink->Llink = delNode->Llink;  // 다음 노드의 Llink 조정
    } else {
        H->Lhead = delNode->Llink;  // 마지막 노드 삭제 시 헤드 조정
    }
    
    free(delNode);  // 메모리 해제
}
```
</details>

**삭제 과정의 핵심**:
```
삭제 전: prevNode ⇄ delNode ⇄ nextNode
삭제 후: prevNode ⇄ nextNode
```

1. **이전 노드의 Rlink 조정**: delNode의 다음 노드를 가리키도록 변경
2. **다음 노드의 Llink 조정**: delNode의 이전 노드를 가리키도록 변경
3. **경계 조건 처리**:
   - 첫 번째 노드 삭제: Fhead 업데이트 필요
   - 마지막 노드 삭제: Lhead 업데이트 필요

**이중 연결 리스트 삭제의 장점**:
- 단순 연결 리스트와 달리 이전 노드를 찾기 위한 순회가 불필요
- O(1) 시간 복잡도로 삭제 가능 (노드 포인터만 있으면)

## 성능 비교 및 활용

### 시간 복잡도 비교

| 연산 | 단순 연결 리스트 | 이중 연결 리스트 | 원형 연결 리스트 |
|------|------------------|------------------|------------------|
| 삽입 (위치 알고 있을 때) | O(1) | O(1) | O(1) |
| 삭제 (노드 포인터 있을 때) | O(n) | O(1) | O(n) |
| 탐색 | O(n) | O(n) | O(n) |
| 역방향 순회 | O(n) | O(1) | O(n) |

### 메모리 사용량 비교

- **단순 연결 리스트**: 노드당 1개 포인터 (최소 메모리)
- **이중 연결 리스트**: 노드당 2개 포인터 + 2개 헤드 포인터
- **원형 연결 리스트**: 노드당 1개 포인터 (단순과 동일)

### 적합한 활용 상황

1. **단순 연결 리스트**:
   - 메모리가 제한적인 환경
   - 순방향 순회만 필요한 경우
   - 삽입/삭제가 주로 앞쪽에서 발생하는 경우

2. **이중 연결 리스트**:
   - 양방향 순회가 빈번한 경우
   - 임의 위치에서의 삭제가 자주 발생하는 경우
   - 브라우저의 앞/뒤 기능, 텍스트 에디터의 undo/redo 등

3. **원형 연결 리스트**:
   - 순환 처리가 필요한 경우
   - 라운드 로빈 스케줄링
   - 게임에서 플레이어 순서 관리 등

## 요약

1. **단순 연결 리스트**는 링크 부분이 하나만 있고, 각각의 노드는 후행 노드만을 가리키는 구조이며, 특정 노드의 선행 노드에 대한 접근은 헤드 노드부터 재검색해야 하는 단점이 있다.

2. **이중 연결 리스트**는 선행 노드를 가리키는 링크 부분과 후행 노드를 가리키는 링크 부분을 가지며, 양방향 순회와 효율적인 삭제 연산이 가능하다.

3. **원형 연결 리스트**는 단순 연결 리스트가 사용하지 않는 마지막 노드의 링크 부분을 활용하면서도 프로그램 성능에 도움이 되도록 하기 위해서 제안되었다. 원형 연결 리스트는 한 방향으로 모든 노드가 원형으로 계속 연결되어 있기 때문에 한 노드로부터 다른 어떤 노드로도 접근할 수 있는 이점이 있다.

4. **성능 특성**: 각 구조는 고유한 장단점을 가지며, 사용 목적과 요구사항에 따라 적절한 구조를 선택해야 한다.
